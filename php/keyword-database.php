<?php 
/* File: buildXML.php
 * Purpose:
 *       Everything needed to completely refresh the XML index file for the Lightroom keyword hierarchy
 *       Find and open all image files 1-by-1
 *       Read the hierarchical keywords in every file, parse them into a nested data structure
 *       Note this doesn't examine the _number_ of files with each keyword - that happens elsewhere
 *       Make another data structure that maps filenames to keyword list
 * Implementation:
 *       This is a two-pass system
 *       1. buildKeywordTreeDatabase() - Read all images in the given folder and create keyword tree.
 *       3. TODO - Warn the administrator if the SAME keyword is used in two different places in the tree.
 * Requires:
 *       When you export images from Lightroom, you must select the options to include keywords:
 *       Lightroom > Metadata > Export keywords
 * Used by:
 *       keywords-to-xml.html
 *       build-keywords-xml2.html
 * Based on:
 *       http://php.net/manual/en/simplexml.examples-basic.php
 *       https://www.tutorialspoint.com/php/php_and_xml.htm 
 * Author:
 *       2018-12-03 Barry Hansen, barry.hansen@gmail.com
 */
// ----- begin edit -----
//    (settings are in 'custom.php')
// ----- end edit -----

require_once($path2php.'adobe-xmp-for-php.php');  // for reading Lightroom's hierarchical keywords from images
require_once($path2php.'custom.php');        // for $supportedFileExtensions
$database = array();   // container for hierarchical keywords and file information

// ---------- saveAutocompleteJavascript ----------
function saveAutocompleteJavascript( $keyword_to_files, $js_path, $js_filename ) {
    // input:  $keyword_to_files =  list of keywords (we'll ignore the files themselves)
    //         $js_path     = path including trailing slash of where to store generated JavaScript
    //         $js_filename = where to store the generated JavaScript

    // starting preamble for file
    global $myOwnerName, $myWebmasterEmail, $mySubdomain, $myDomain, $myTLD;
    $maxLineLength = 92;
    $result = "/* File:      $js_filename".PHP_EOL 
            . " * Website:   $mySubdomain$myDomain$myTLD".PHP_EOL 
            . " * Webmaster: $myOwnerName, $myWebmasterEmail".PHP_EOL 
            . " * Generated on: ".date('r').PHP_EOL 
            . " * Generated by: ".basename(__FILE__).PHP_EOL 
            . " */".PHP_EOL 
            . '$( ".autocomplete" ).autocomplete({'.PHP_EOL
            . 'source: [ '.PHP_EOL;

    // convert keyword database to javascript strings
    ksort($keyword_to_files);
    $line = '    ';
    $quote = "'";
    $comma = ",";
    $space = " ";
    foreach($keyword_to_files as $keyword => $files) {
        $line .= json_encode($keyword).$comma.$space;

        // looks nicer in JavaScript to break up JavaScript into convenient line lengths
        if (strlen($line) > $maxLineLength) {
            $result .= $line.PHP_EOL;
            $line = '    ';
        }
    }
    $result .= $line.PHP_EOL;

    // ending closing statement to file
    $result .= ']'.PHP_EOL 
             . '});'.PHP_EOL.PHP_EOL;

    if (is_writeable($js_path.$js_filename)) {
        $rc = file_put_contents($js_path.$js_filename, $result);
        if ($rc === false) {
            showError("Server error: Failed to write autocomplete keyword file to disk. ($js_filename)".PHP_EOL
                    ."<br/>Please report the problem to the <a href=\"mailto:$myWebmasterEmail\">webmaster</a>.".PHP_EOL,
                    __FILE__, __LINE__);
        } else {
            echo "<p>Completed: Updated <a href=\"/$js_filename\">JavaScript file</a> successfully.</p>".PHP_EOL;
        }
    } else {
        // Error: file is not writeable. Show a detailed message to help webmaster debug the problem.
        $userName = get_current_user(); // "owner of the script file" .e.g. __FILE__ 

        $processUserName = posix_getpwuid(posix_geteuid())['name'];

        $folderName = dirname($js_path.$js_filename);
        $folderPermissions = substr(sprintf('%o', fileperms($folderName)), -4);
        $folderOwnerNbr = fileowner($folderName);
        $folderOwner = posix_getpwuid($folderOwnerNbr);
        $folderOwnerName = $folderOwner['name'];

        $filePermissions = substr(sprintf('%o', fileperms($js_path.$js_filename)), -4);
        $fileOwnerNbr = fileowner($js_path.$js_filename);
        $fileOwner = posix_getpwuid($fileOwnerNbr);
        $fileOwnerName = $fileOwner['name'];

        showError("Server error: Unable to update autocomplete keyword file because it is not writable.".PHP_EOL
            . "<br/>Folder name = '$folderName' &nbsp;with permissions = $folderPermissions &nbsp;and owner number $folderOwnerNbr &nbsp;and owner='$folderOwnerName'".PHP_EOL
            . "<br/>File name = '$js_filename' &nbsp;with permissions = $filePermissions &nbsp;and owner number $fileOwnerNbr &nbsp;and owner='$fileOwnerName'".PHP_EOL
            . "<br/>Apache process user = '$processUserName'".PHP_EOL
            . "<br/>PHP file owned by user = '$userName'",
             __FILE__, __LINE__);
    }
   
}
// ---------- buildKeywordTreeDatabase ----------
function buildKeywordTreeDatabase($imageFolder, $file_list, $outputTreeFile) {
    // Top level routine that contains all work necessary to read all the image files,
    // build a database of hierarchical keywords, and write the result as XML
    //
    // In keeping with the "do one thing" principle, this function is separate from the
    // keyword-to-files database, even though they both read the same set of images.
    //
    // input: $imageFolder = where to read all the image files from
    //        $outputTreeFile  = name of resultant hierarchical XML file 
    global $database;   // global so we don't have to copy or pass large array back and forth

    if (!file_exists(PATH2ROOT.$imageFolder)) {
        // error, folder not found, issue message
        showError("<strong>Error:</strong> Image folder ($imageFolder) was not found.", __FILE__, __LINE__);

    } elseif (!is_dir(PATH2ROOT.$imageFolder)) {
        // error, filename not folder name, issue another message
        showError("<strong>Error:</strong> Specified folder ($imageFolder) is not actually a folder.", __FILE__, __LINE__);

    } else {
        // success, so far

        $adobePHP =& adobeXMPforPHP::get_instance();

        $ii = 0;    // loop counter
        foreach ($file_list as $file) {
            // read lightroom keywords for one file
            $fqName = PATH2ROOT."$imageFolder/$file";
            $image_xmp = $adobePHP->get_xmp( $fqName );
            $keyset = $image_xmp['Hierarchical Keywords'];
            //debugDump($keyset, __FILE__, __LINE__, 'buildKeywordTreeDatabase', '$keyset');    // debug

            // add keywords to database
            if (!empty($keyset)) {
                // at this point, we have an array of one or more pipe-separated strings
                // e.g.     "Entities|Clothing|Eyewear"
                // becomes: $database[Entities][Cothing][Eyewear] = array(file1, file2, file3, ...)
                addKeysetToDatabase($keyset, $file);

            } else {
                // since this image has no keywords, add our own keyword to make it findable
                global $noKeywordsKeyset;
                addKeysetToDatabase($noKeywordsKeyset, $file);
                //debugDump($database, __FILE__, __LINE__, 'buildKeywordTreeDatabase()', $database);    // debug

                // show helpful warning to webmaster
                global $detailPage;
                $urlFilename = rawurlencode($file);     // replace spaces with '%20' for valid URL
                $urlFQname = "/$imageFolder/$urlFilename";
    
                showWarning(sprintf('Image <a href="%s">%s</a> contains no hierarchical keywords. ', $urlFQname, $file)
                           .sprintf('<a href="%s?file=%s">(details)</a> ', $detailPage, $urlFilename, $file) );
    
            }
            //debugDump($database, __FILE__, __LINE__, 'buildKeywordTreeDatabase()', $database);    // debug
            $ii++;
            global $loopLimit;
            if ($loopLimit && $ii>=$loopLimit) {
               showWarning("Ending loop early during tree construction after $loopLimit files.", __FILE__, __LINE__);   // debug
               break;
           }
        }
        sortKeywordTree($database); // Windows used: sortKeywordTree(&$database);
        //debugDump($database, __FILE__, __LINE__, 'buildKeywordTreeDatabase()', '$database');  // debug
    }
    return $database;
}
// ---------- sortKeywordTree ----------
function sortKeywordTree(&$database, $level=1) {
    // Alphabetize the keyword tree, for branches below the top level
    // (The top level remains in the original Lightroom sequence order, so the archivist can
    //  control which major sections come first by choosing top names in alphabetical order.)
    // This is a recursive function.
    if (is_array($database)) {
        foreach ($database as $key => &$value) {
            if (is_array($value)) {
                sortKeywordTree($value, $level+1);  // RECURSIVE
            }
        }
        if ($level >1) {
            ksort($database);
        }
    }
    return;
}
// ---------- buildKeywordToFilesDatabase ----------
function buildKeywordToFilesDatabase($imageFolder, $file_list, $outputflatfile) {
    // Top level routine to read the image files (again) and build a list of keywords. 
    // For each keyword, WITHOUT regard to nesting or tree structure, make a list of all 
    // of its files. This is a cache to provide straightforward "search by keyword" later.
    //
    // In keeping with the "do one thing" principle, this function is separate from the
    // keyword hierarchy database above, even though they both read the same set of images.
    //
    // input: $imageFolder = where to read all the image files from
    //        $outputFlatFile  = name of resultant flat keyword->filenames XML file

    $adobePHP =& adobeXMPforPHP::get_instance();

    $flatkeys = array();    // init returned array
    $ii = 0;    // loop counter
    foreach ($file_list as $file) {
        // read lightroom keywords for one file
        $fqName = PATH2ROOT."$imageFolder/$file";
        $image_xmp = $adobePHP->get_xmp( $fqName );
        $keyset = $image_xmp['Hierarchical Keywords'];
        //debugDump($keyset, __FILE__, __LINE__, 'buildKeywordToFilesDatabase()', '$keyset');  // debug

        if (empty($keyset)) {
            // this image has no keywords, so add our own special marker so the image can be found
            global $noKeywordsKeyset;
            $keyset = $noKeywordsKeyset;

            // warn the webmaster to review this file in Lightroom and add keywords
            global $myLargeImageFolder;
            $imgName = $myLargeImageFolder.'/'.$file;
            echo "<p>Image: <b>$file</b> contains no hierarchical keywords. "
                .sprintf('(<a href="%s">image</a>) ', $imgName)
                ."</p>".PHP_EOL;
        }

        // add keywords to database
        // at this point, we have an array of one or more pipe-separated strings
        // e.g.     "Entities|Clothing|Eyewear"
        // becomes: $flatkeys[Entities] = array(file1, file2, ...)
        //          $flatkeys[Clothing] = array(file1, file2, ...)
        //          $flatkeys[Eyewear]  = array(file1, file2, ...)

        foreach ($keyset as $pipedkeys) {
            $keylist = explode('|', $pipedkeys);
            foreach ($keylist as $key) {
                // add this one keyword to our lookup table
                $flatkeys[$key][] = $file;
            }
        }

        $ii++;
        //debugDump($database, __FILE__, __LINE__, 'buildKeywordToFilesDatabase()', '$database');   // debug
        global $loopLimit;     // from custom.php
        if ($loopLimit && $ii>=$loopLimit) {
           showWarning("Ending loop early in keyword-to-files construction after $loopLimit files.", __FILE__, __LINE__);   // debug
           break;
       }
    }

    // Having processed all files in this manner, there are many duplicate file entries 
    // for the higher-level keywords. 
    // For example, a file with "Entities|Clothing" and "Entities|Buildings" should only tally "Entities" once
    // but the code above has added the same filename twice to the "Entities" keyword.
    //debugDump($flatkeys, __FILE__, __LINE__, 'buildKeywordToFilesDatabase()', '$flatkeys'); // debug - before
    $result = array();
    foreach ($flatkeys as $keyword => $filelist) {
        $result[$keyword] = array_unique($filelist);
    }
    //debugDump($result, __FILE__, __LINE__, 'buildKeywordToFilesDatabase()', '$result'); // debug - after cleanup

    // We strongly recommend all keywords begin with initial upper-case letter, for consistency
    foreach ($flatkeys as $keyword => $filelist) {
        $firstChar = substr($keyword, 0, 1);
        if ($firstChar != strtoupper($firstChar)) {
            global $detailPage;
            $firstFile = $filelist[0];
            showWarning("Keyword '<b>$keyword</b>' starts with lower-case '<b>$firstChar</b>' "
                       ."and we recommend initial uppercase for all keywords. "
                       ."(See <a href=\"$detailPage?file=$firstFile\">$firstFile</a>)");
        }
    }
    
    return $result;
}

// ---------- readTreeDatabase() ----------
function readTreeDatabase($filename) {
    // converse of writeTreeDatabase()
    return unserializeFromDisk($filename.'.php');
}
function readTreeDatabaseXML($xmlfilename) {
    getXML($xmlfilename.'.xml');
}

// ---------- writeTreeDatabase() ----------
function writeTreeDatabase($database, $outputTreeFile) {
    writeTreeDatabaseXML($database, $outputTreeFile.'.xml');  // human readable (slowest)
    serializeToDisk($database, PATH2ROOT.$outputTreeFile.'.php');       // machine readable (fastest)
}
function writeTreeDatabaseXML($database, $outputTreeFile) {
    // SimpleXML is good for parsing existing XML documents, but it can't create a new XML file from scratch.
    // The easiest way to generate an XML document is to build a PHP array whose structure mirrors 
    // the XML document and then to iterate through the array, printing each element with 
    // appropriate formatting.  https://www.tutorialspoint.com/php/php_and_xml.htm

    $xml = new SimpleXMLElement('<shmkeywords/>');
    $today = date('r');
    $xml->addAttribute('generated', $today);

    $bull = '&nbsp;&nbsp;- ';

    // TODO - rewrite this as recursive routine
    // Process elements of L1
    foreach ($database as $key1 => $value1) {
        //echo "<br/>1. \$key1 => \$value1: $key1 => $value1".PHP_EOL;   // debug
        $level1 = $xml->addChild('L1');
        $level1['name'] = $key1;
        //$level1['count'] = $value1['count'];

        if (!is_array($value1)) {
            echo "<p>Internal Error: Expected array but got key=>value of ($key1)=>($value1)</p>".PHP_EOL;
        }

        // Process elements of L2
        foreach ($value1 as $key2 => $value2) {
            //echo "<br/>$bull 2. \$key2 => \$value2: [$key2] => [$value2]".PHP_EOL;   // debug
            if (strcmp($key2, 'count') == 0) {
                continue;   // the count was reported above; 'count' is not a category
            } elseif (is_numeric($key2)) {
                $level1->addChild('file', $value2);
            } elseif (is_array($value2)) {
                $level2 = $level1->addChild('L2');
                $level2['name'] = $key2;
                //$level2['count'] = $value2['count'];

                // Process elements of L3
                foreach ($value2 as $key3 => $value3) {
                    //echo "<br/>$bull$bull 3. \$key3 => \$value3: [$key3] => [$value3]".PHP_EOL;   // debug
                    if (strcmp($key3, 'count') == 0) {
                        continue;   // the count was reported above; 'count' is not a category
                    } elseif (is_numeric($key3)) {
                        $level2->addChild('file', $value3);
                    } elseif (is_array($value3)) {
                        $level3 = $level2->addChild('L3');
                        $level3['name'] = $key3;
                        //$level3['count'] = $value3['count'];

                        // Process elements of L4
                        foreach ($value3 as $key4 => $value4) {
                            //echo "<br/>$bull$bull$bull 4. \$key4 => \$value4: [$key4] => [$value4]".PHP_EOL;   // debug
                            if (strcmp($key4, 'count') == 0) {
                                continue;
                            } elseif (is_numeric($key4)) {
                                $level3->addChild('file', $value4);
                            } elseif (is_array($value4)) {
                                $level4 = $level3->addChild('L4');
                                $level4['name'] = $key4;
                                //$level4['count'] = $value4['count'];

                                // Process elements of L5
                                foreach ($value4 as $key5 => $value5) {
                                    //echo "<br/>$bull$bull$bull$bull 5. \$key5 => \$value5: [$key5] => [$value5]".PHP_EOL;   // debug
                                    if (strcmp($key5, 'count') == 0) {
                                        continue;
                                    } elseif (is_numeric($key5)) {
                                        $level4->addChild('file', $value5);
                                    } elseif (is_array($value5)) {
                                        $level5 = $level4->addChild('L5');
                                        $level5['name'] = $key5;
                                        //$level5['count'] = $value5['count'];

                                        // Process elements of L6
                                        foreach ($value5 as $key6 => $value6) {
                                            //echo "<br/>$bull$bull$bull$bull 5. \$key5 => \$value5: [$key5] => [$value5]".PHP_EOL;   // debug
                                            if (strcmp($key6, 'count') == 0) {
                                                continue;
                                            } elseif (is_numeric($key6)) {
                                                $level5->addChild('file', $value6);
                                            } elseif (is_array($value6)) {
                                                $level6 = $level5->addChild('L6');
                                                $level6['name'] = $key6;
                                                //$level6['count'] = $value6['count'];

                                                // TODO - rewrite this as recursive routine if you need unlimited levels
                                                showError("Processing keyword '$key6' at nesting level 6.'
                                                .' The keyword tree has more nested levels than is currently supported.'
                                                .' Level 7 has not been implemented.'
                                                .' Your webmaster questions whether you can justify nesting keywords so deeply.' 
                                                .' <b>Archivist:</b> Please use Lightroom to review your keyword hierarchy and re-export your images.",
                                                __FILE__, __LINE__);
                                            }
                                        } // end L6
                                    }
                                } // end L5
                            }
                        } // end L4
                    }
                } // end L3
            }
        } // end L2
    } // end L1

    //echo '<pre>$xml = '; echo $xml->asXML(); echo '</pre>'.PHP_EOL; // debug
    $xml->asXML(PATH2ROOT.$outputTreeFile);
}

// ---------- writeKeywordFlatDatabase ----------
function writeKeywordFlatDatabase($database, $outputFlatFile) {
    // Input:  $database = array( key1=>array(file1, file2, ...), 
    //                            key2=>array(file3, file4, ...), 
    //                            ...
    //         $outputFlatFile = string containing filename (no extension!)

    writeKeywordFlatDatabaseXML($database, $outputFlatFile.'.xml'); // human readable (slowest)
    serializeToDisk($database, PATH2ROOT.$outputFlatFile.'.php');             // machine readable (fastest)
}

function writeKeywordFlatDatabaseXML($database, $outputFlatFile) {
    // Input:  $database = array( key1=>array(file1, file2, ...), 
    //                            key2=>array(file3, file4, ...), 
    //                            ...
    //         $outputFlatFile = string containing filename (no extension!)
    //

    //echo "<p>writeKeywordFlatDatabaseXML(\$database, $outputTreeFile) begins...".PHP_EOL; // debug at entry
    //echo "<br/>writeKeywordFlatDatabaseXML(\$database, $outputFlatFile)".PHP_EOL;
    $xml = new SimpleXMLElement('<shmflatkeywords/>');
    $today = date('r');
    $xml->addAttribute('generated', $today);

    // Process elements of L1
    foreach ($database as $keyword => $files) {
        $item = $xml->addChild( 'keyword' );
        $item->addChild( 'name', $keyword );
        foreach ($files as $filename) {
            $item->addChild( 'file', $filename );
        }
    }

    //debugDump($xml, __FILE__, __LINE__, 'writeKeywordFlatDatabase()', '$xml'); // debug at exit
    $xml->asXML(PATH2ROOT.$outputFlatFile);
}

// ---------- readKeywordFlatDatabase ----------
function readKeywordFlatDatabase($flatdb_filename) {
    $keywordinfo = unserializeFromDisk($flatdb_filename.'.php');          // fastest
    //$keywordinfo = readKeywordFlatDatabaseXML($flatdb_filename.'.xml'); // slowest
    return $keywordinfo;
}
function readKeywordFlatDatabaseXML($xml_filename) {
    // Fetch the image database into a data structure
    //
    // This is the converse of writeKeywordFlatDatabase()
    //
    // Returns:  $database = array( key1=>array(file1, file2, ...), 
    //                              key2=>array(file3, file4, ...), 
    //                              ...

    $simplexml = simplexml_load_file( $xml_filename );    // returns object of type SimpleXML
    //debugDump($simplexml, __FILE__, __LINE__, 'readKeywordFlatDatabase()', '$simplexml'); // debug

    // Convert SimpleXML objects into plain strings
    // This lookup table is needed for efficient searching for keywords
    $keywordinfo = array();
    foreach ($simplexml as $obj) {
        $keyword = (string)$obj->name;
        $keywordinfo[$keyword] = (string)$obj->title;
        foreach ($obj->file as $filename) {
            $keywordinfo[$keyword][] = (string)$filename;
        }
    }
    return $keywordinfo;
}

// ---------- addKeysetToDatabase() ----------
function addKeysetToDatabase($keyset, $file) {
    // at this point, we have an array of one or more pipe-separated strings
    // input:   [0] = "Entities|Clothing|Costumes"
    //          [1] = "Entities|Clothing|Footwear"
    // saved in database as:
    //          $database[Entities][Clothing][Costumes] = array(file1, file2, file3, ...)
    //          $database[Entities][Clothing][Footwear] = array(file1, file2, file3, ...)

    foreach ($keyset as $item) {
        addOneKeyToDatabase($item, $file);
    }
}

// ---------- addOneKeyToDatabase() ----------
function addOneKeyToDatabase($key, $file) {
    // here we have one single pipe-separated string representing one single hierarchical keyword
    // input:   "Entities|Clothing|Costumes"
    // added to database as:
    //          $database[Entities][Clothing][Costumes] = array(..., filename, ...)
    global $database;   // global so we don't have to copy or pass array back and forth

    $keylist = explode('|', $key);
    $pointer = &$database;      // starting at root, and keep track of position as we descend into multi-level array
    $nestnumber = '0';          // keep track of nesting level, to generate strings 'L1', 'L2', 'L3', ...
    foreach ($keylist as $level) {
        $nestnumber++;
        $nodename = "L$nestnumber";

        if ($pointer && array_key_exists( $level, $pointer )) {
            // have already created this node earlier, do nothing
            //echo "$file: already created node $nodename for '$level'<br/>".PHP_EOL;  // debug

        } else {
            // this is new key, create it in the database
            //echo "$file: creating $nodename for <b>$level</b><br/>".PHP_EOL;   // debug
            $pointer[$level] = array();     // create array to contain info for this new keyword

        }

        $pointer = &$pointer[$level];    // remember this position in the database, for the next pass thru the loop

    }

    // finally, the hierarchical keyword is guaranteed to exist in the database
    // save the image file name only once, at the last leaf in the keyword hierarchy
    $pointer[] = $file;     //add this filename to the database record

    //debugDump($database, __FILE__, __LINE__, 'addOneKeyToDatabase', '$database');    // debug
}

// ----- showKeywordTreeStatistics ----------
function showKeywordTreeStatistics($database) {
    // You should call this function after generating the database of keywords, and before writing the XML file
    //debugDump($database, __FILE__, __LINE__, 'showKeywordTreeStatistics()', '$database');    // debug

    $level = array_fill(1, 10, 0);   // init accumulators (at least 6) to 0, one for each level of nesting
    $keylist = array_fill(1, 6, ''); // init output strings 

    // TODO - rewrite this as recursive routine
    // TODO - similar to "saveAutocompleteJavascript()" above
    // Count the number of top-level keywords
    $top = '';
    foreach ($database as $key1 => $value1) {
        $level[1]++;
        $comma = strlen($keylist[1]) ? ', ' : '';
        $keylist[1] .= $comma . $key1;

        if (is_array($value1)) {
            // Count the L2 keywords
            foreach ($value1 as $key2 => $value2) {
                if (!is_numeric($key2)) {
                    $level[2]++;
                    $comma = strlen($keylist[2]) ? ', ' : '';
                    $keylist[2] .= $comma . $key2;
                }

                if (is_array($value2)) {
                    // Count the L3 keywords
                    foreach ($value2 as $key3 => $value3) {
                        if (!is_numeric($key3)) {
                            $level[3]++;
                            $comma = strlen($keylist[3]) ? ', ' : '';
                            $keylist[3] .= $comma . $key3;

                            if (is_array($value3)) {
                                // Count the L4 keywords
                                foreach ($value3 as $key4 => $value4) {
                                    if (!is_numeric($key4)) {
                                        $level[4]++;
                                        $comma = strlen($keylist[4]) ? ', ' : '';
                                        $keylist[4] .= $comma . $key4;

                                        if (is_array($value4)) {
                                            // Count the L5 keywords (if any)
                                            foreach ($value4 as $key5 => $value5) {
                                                if (!is_numeric($key5)) {
                                                    $level[5]++;
                                                    $comma = strlen($keylist[5]) ? ', ' : '';
                                                    $keylist[5] .= $comma . $key5;

                                                    if (is_array($value5)) {
                                                        // Count the L6 keywords (we don't expect any)
                                                        foreach ($value5 as $key6 => $value6) {
                                                            if (!is_numeric($key6)) {
                                                                $level[6]++;
                                                                $comma = strlen($keylist[6]) ? ', ' : '';
                                                                $keylist[6] .= $comma . $key6;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    $totalkeys = array_sum($level);
    echo '<ul class="statistics">'.PHP_EOL 
        ."  <li><b>$totalkeys</b> total keywords found</li>".PHP_EOL
        ."  <li><b>$level[1]</b> top-level keywords: <br/>$keylist[1]</li>".PHP_EOL 
        ."  <li><b>$level[2]</b> second-level keywords: <br/>$keylist[2]</li>".PHP_EOL
        ."  <li><b>$level[3]</b> third-level keywords: <br/>$keylist[3]</li>".PHP_EOL
        ."  <li><b>$level[4]</b> fourth-level keywords: <br/>$keylist[4]</li>".PHP_EOL
        ."  <li><b>$level[5]</b> fifth-level keywords: <br/>$keylist[5]</li>".PHP_EOL
        ."  <li><b>$level[6]</b> sixth-level keywords <br/>$keylist[6]</li>".PHP_EOL
        ."</ul>".PHP_EOL;
}

// ----- showKeywordFlatStatistics ----------
function showKeywordFlatStatistics($database) {
    // You should call this function after generating the database of keywords, and before writing the XML file
    // Input:  $database = array( key1=>array(file1, file2, ...), 
    //                            key2=>array(file3, file4, ...), 
    //                            ...
    // Output: HTML
    //echo "<h4>Database Statistics</h4>".PHP_EOL;
    //debugDump($database, __FILE__, __LINE__, 'showKeywordFlatStatistics()', '$database');    // debug

    // templates for output messages
    $start = '<ul class="statistics">'.PHP_EOL;
    $unique= '  <li><b>%d</b> total unique keywords found</li>'.PHP_EOL;
    $item  = '  <li><b>%d</b> keywords have <b>%d</b> files: %s</li>'.PHP_EOL;    // plural 'files'
    $item1 = '  <li><b>%d</b> keyword has <b>%d</b> files using that keyword: %s</li>'.PHP_EOL; // singular 'file'
    $end   = '</ul>'.PHP_EOL;

    $keycount = array();   // 

    foreach ($database as $key => $value) {
        $number_of_files = count($value);
        $comma = strlen($keycount[$number_of_files]['keylist']) == 0 ? '' : ', ';
        
        $keycount[$number_of_files]['count']++;
        $keycount[$number_of_files]['keylist'] .= $comma.$key;
    }

    // Sort by "number of files"
    ksort($keycount);

    echo $start;
    printf($unique, count($database));
    //showFencepost(__FILE__, __LINE__);  // debug
    foreach ($keycount as $count => $info) {
        if ($info['count'] == 1) {
            printf($item1, $info['count'], $count, $info['keylist']);   // singular 'file'
        } else {
            printf($item, $info['count'], $count, $info['keylist']);    // plural 'files'
        }
    }
    echo $end;
}
